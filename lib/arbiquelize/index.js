'use strict';

const Arbiter = require('./arbiter');
const difference = require('lodash/difference');
const filter = require('lodash/filter');
const flatMap = require('lodash/flatMap');
const { format } = require('util');
const groupBy = require('lodash/groupBy');
const initial = require('lodash/initial');
const invoke = require('lodash/invoke');
const map = require('lodash/map');
const maxBy = require('lodash/maxBy');
const objectHash = require('object-hash');
const pick = require('lodash/pick');
const Promise = require('bluebird');
const reduce = require('lodash/reduce');
const sortBy = require('lodash/sortBy');
const Sqlize = require('../sqlize');

const { Sequelize } = Sqlize;

const isFunction = arg => typeof arg === 'function';
const isModel = Ctor => Ctor && Ctor.prototype instanceof Arbiquelize.Model;
const isProduction = process.env.NODE_ENV === 'production';

const { DataTypes } = Sequelize;
const { validate } = DataTypes.STRING.prototype;
DataTypes.STRING.prototype.validate = function (value, options) {
  let isValid = validate.call(this, value, options);
  if (isFunction(this.options.validate)) {
    isValid = isValid && this.options.validate.call(this, value, options);
  }
  return isValid;
};

class SalesforceId extends DataTypes.STRING {
  constructor(length = 18) {
    super(length);
    this.options.validate = function (value, options) {
      return SalesforceId.validate(this, value, options);
    };
  }

  static validate({ options }, value, _options) {
    const pattern = new RegExp(`^[a-z0-9]{${options.length}}$`, 'i');
    if (!pattern.test(value)) {
      const message = format('%j is not a valid Salesforce ID', value);
      throw new Sequelize.ValidationError(message);
    }
    return true;
  }
}
DataTypes.SALESFORCE_ID = SalesforceId;
DataTypes.SALESFORCE_ID.prototype.key = DataTypes.SALESFORCE_ID.key = 'SALESFORCE_ID';
Sequelize.SALESFORCE_ID = Sequelize.Utils.classToInvokable(DataTypes.SALESFORCE_ID);

class Arbiquelize extends Sqlize {
  constructor() {
    super(...arguments);
    this._arbiter = this._initArbiter();
    this.Sequelize = this.constructor;
  }

  _initArbiter({ salesforce } = this.options) {
    const { oauth2, loginUrl, credentials } = salesforce;
    const connection = { oauth2, loginUrl };
    return Arbiter.configure({ ...credentials, connection });
  }

  get arbiter() {
    return this._arbiter;
  }

  define(Model) {
    // Keep backwards compatibility.
    if (!isModel(Model)) return super.define(...arguments);
    const { DataTypes, Arbiter, Promise } = this.Sequelize;
    let fields = invoke(Model, 'fields', DataTypes, Arbiter.Tags, this) || {};
    const options = invoke(Model, 'options', Arbiter.Tags) || {};
    if (options.freezeTableName !== false) options.freezeTableName = true;
    if (options.paranoid !== false) options.paranoid = true;
    if (options.timestamps !== false) options.timestamps = true;
    if (options.sf.deletable !== false) options.sf.deletable = true;
    fields = this.addDefaultFields(fields, options);
    const sfAttributes = reduce(fields, (acc, { sf }, name) => {
      if (!sf) return acc;
      sf.sf = sf.name;
      return Object.assign(acc, { [name]: sf });
    }, {});
    Model.$sfAttributes = sfAttributes;
    const schema = new Arbiter.Schema(options.sf.schemaName, sfAttributes);
    Model.$SfModel = Arbiter.model(Model.name, schema);
    this.wrapMethods(Model, Promise);
    Model.init(fields, { ...options, sequelize: this });
    return Model;
  }

  addDefaultFields(fields, options) {
    const { DataTypes } = this.Sequelize;
    const head = {};
    const tail = {};
    if (!Object.values(fields).find(it => it.primaryKey)) {
      Object.assign(head, {
        id: {
          type: DataTypes.SALESFORCE_ID,
          allowNull: false,
          primaryKey: true,
          sf: { name: 'Id' }
        }
      });
    }
    const { sf } = options;
    if (sf && sf.deletable) {
      Object.assign(tail, {
        sfIsDeleted: {
          _autoGenerated: true,
          type: DataTypes.BOOLEAN,
          allowNull: false,
          defaultValue: false,
          field: 'sf_deleted',
          sf: { name: 'IsDeleted', type: 'boolean' }
        }
      });
    }
    fields = Object.assign({}, head, fields, tail);
    return super.addDefaultFields(fields, options);
  }

  addTimestamps(fields, options) {
    fields = super.addTimestamps(fields, options);
    const { DataTypes } = this.Sequelize;
    const tail = {};
    Object.assign(tail, {
      sfCreatedAt: {
        _autoGenerated: true,
        type: DataTypes.DATE,
        allowNull: false,
        defaultValue: new Date(0),
        field: 'sf_created_at',
        sf: { name: 'CreatedDate', type: 'date' }
      },
      sfUpdatedAt: {
        _autoGenerated: true,
        type: DataTypes.DATE,
        allowNull: false,
        defaultValue: new Date(0),
        field: 'sf_updated_at',
        sf: { name: 'LastModifiedDate', type: 'date' }
      }
    });
    return Object.assign({}, fields, tail);
  }
}

Arbiquelize.Model = class extends Sqlize.Model {
  static withChildren(options) {
    return this.scope({ method: ['includeChildren', options] });
  }

  static async salesforce(action) {
    const result = await Promise.resolve(action(this.$SfModel));
    const attributes = ['id', ...Object.keys(this.$sfAttributes)];
    if (Array.isArray(result)) return result.map(it => pick(it, attributes));
    return pick(result, attributes);
  }

  static async fetchFromSF() {
    const { DateTime } = Arbiter;
    const version = await this.getVersion();
    const where = { sfUpdatedAt: { $gt: DateTime(version) } };
    return this.salesforce(model => model.find(where).select('*'));
  }

  static async pullFromSF(records) {
    // console.log(' ======= pullin ' + this.name);
    // return Promise.resolve(true);
    if (!records) records = await this.fetchFromSF();
    const upserts = await this.bulkCreate(this.removeDuplicates(records));
    const latestRecord = maxBy(records, 'sfUpdatedAt');
    if (latestRecord) await this.setVersion(latestRecord.sfUpdatedAt);
    return upserts;
  }

  static async pushToSF(payload) {
    const action = it => this.salesforce(model => model.new(it).save());
    if (Array.isArray(payload)) {
      const sfRecords = await Promise.map(payload, action);
      return this.bulkCreate(sfRecords);
    }
    const sfRecord = await action(payload);
    return this.upsert(sfRecord, { returning: true }).then(([item]) => item);
  }

  static bulkCreate(results) {
    const attributes = Object.keys(this.$writableAttributes);
    const options = {
      updateOnDuplicate: attributes,
      // NOTE: Individual model validation is turned off by default!
      validate: !isProduction
    };
    return super.bulkCreate(results, options);
  }

  static createGrunt(data) {
    const query = new Arbiter.Query(this.$SfModel).select('*');
    const { fields, mappings } = query._fields.build();
    const [grunt] = query.createGrunts([data], fields, mappings);
    return grunt;
  }

  // If multiple instances with equal upsert key values sent
  // keeps only the last updated one among them
  static removeDuplicates(rows) {
    const upsertKeys = map(filter(this.tableAttributes, 'upsertKey'), 'fieldName');
    if (!upsertKeys.length) return rows;
    const duplicates = groupBy(rows, it => objectHash(pick(it, upsertKeys)));
    const obsolete = flatMap(duplicates, group => {
      return initial(sortBy(group, 'sfUpdatedAt'));
    });
    return difference(rows, obsolete);
  }
};
Arbiquelize.Arbiter = Arbiter;
Arbiquelize.Arbiter.Tags = require('./tags');

module.exports = Arbiquelize;
